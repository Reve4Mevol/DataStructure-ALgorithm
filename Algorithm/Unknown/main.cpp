//
// Created by Administrator on 2021-10-01.
//
#include <iostream>

/**
 * question: 100桶饮料，其中一桶混有有害物体，用若干自愿者试验，每个自愿者可以尝试一桶或者多桶饮料，
 * 自愿者喝到有害饮料后2小时会发生恶心、出虚汗等反应，恶心持续20分钟后自然消失。三个小时内需要找到有
 * 害物体的桶，问至少要多少名自愿者?
 */

/**
 * solution(true)：假设编号为100桶用1到100个整数编号，这个编号可以用二进制表示，
 * 需7位二进制表示128>100，如1号桶是二进制0000001，5号桶是0000101,........
 * 找7个志愿者，对应桶二进制的由高到低编号，如 a,b,c,d,e,f,g。a对应二进制的最高位，g对应二进制的最低位，每个志愿者分配一个杯子。
 * 分别从1-100个桶中取出饮料(多少没关系，并没有说需要多少饮料才能引起不适反应),如第1号桶二进制是0000001，只给g 杯中倒饮料，
 * 也即二进制位1的对应志愿者才分配饮料，5号桶是0000101，则需给e和g 杯中倒饮料（注意:每次分配饮料是可以混合累加在一起的，不需要另外的杯子)。
 * 100个桶分配完毕，每个志愿者喝完杯中饮料后20分钟，看志愿者中那几个有反应，如果c，e，g有反应，则7位志愿者对应的二进制为:0010101
 * (有反应的志愿者对应的二进制位l，其他为0，转化为十进制，就是质量有问题的桶编号)，0010101的十进制是21，则21号桶质量有问题。
 */

/**
 * solution(false)：每次分成几份时候可以，空出一个样本出来，这样的话另外两个确认结果，空出来的有没有毒就能看出来
 * 再吧问题拆分出来，算另外两份，每一份的最少志愿者人数，那么等于还是同一个问题
 * 动态规划思想
 * f(x) = min{ f(y) + f(x-y-1) };
 * f(3) = 2;
 * f(2) = 1;
 * f(1) = 1;
 * !!!! 复杂度太高，程序执行超时 !!!!
 * @param n
 * @return
 */
int getMinVolunteer(const int &n) {
    if (n == 1 || n == 2) {
        // 只有一份或者两份样本时候，至少需要一个志愿者去喝
        return 1;
    }
    int minNum, volunteerCount;
    for (int i = 1; i < n - 1; ++i) {
        // 可以留一杯不检验，如果喝另外几份的没问题，说明有问题的是那一杯
        volunteerCount = getMinVolunteer(i) + getMinVolunteer(n - i - 1);
        // 第一次循环，只有一个结果作为最小值
        if (i == 1) {
            minNum = volunteerCount;
        } else {
            // 后续循环过程不断比较更新最小值
            minNum = std::min(minNum, volunteerCount);
        }
    }
    return minNum;
}




int main() {
    return 0;
}